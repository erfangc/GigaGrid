import * as React from 'react';
import { ClassAttributes } from 'react';
import { Column } from '../models/ColumnLike';
import { GigaStore, GigaAction, GigaActionType } from '../store/GigaStore';
import { Dispatcher } from 'flux';
import { FrozenTableBody } from './TableBody/FrozenTableBody';
import { ScrollableTableBody } from './TableBody/ScrollableTableBody';
import { TableHeader } from './TableHeader';
import { InitializeAction } from '../store/handlers/InitializeReducer';
import { ChangeRowDisplayBoundsAction } from '../store/handlers/ChangeRowDisplayBoundsReducer';
import { ReduceStore } from 'flux/utils';
import { ServerStore } from '../store/ServerStore';
import { GigaProps } from './GigaProps';
import { GigaState } from './GigaState';
import { GridResizeAction } from '../store/handlers/GridResizeReducer';
import * as ReactDOM from 'react-dom';
import '../layout.css';
export interface GridComponentProps<T> {
    dispatcher: Dispatcher<GigaAction>;
    // idk if this is a good idea - but sub components often need to refer to things like callbacks - really annoying to pass them at each level
    // making them optional so tests' don't complain as much
    gridProps?: GigaProps;
}

export interface AdditionalButton {
    name: string;
    customCallback: () => any;
}

/**
 * The root component of this React library. assembles raw data into `Row` objects which are then translated into their
 * virtual DOM representation
 *
 * The bulk of the table state is stored in `tree`, which contains subtotal and detail rows
 * Rows can be hidden if filtered out or sorted among other things, subtotal rows can be collapsed etc
 * mutations to the state of table from user initiated actions can be thought of as mutates on the `tree`
 *
 * **IMPORTANT** GigaGrid the component does not actually mutate its own state nor give its children the ability
 * to mutate its state. State mutation is managed entirely by the GigaStore flux Store. Events generated by the
 * children of this component are emitted to a central dispatcher and are dispatched to the GigaStore
 *
 * **Developer Warning** Please DO NOT pass a reference of this component to its children nor call setState() in the component
 **/

export class GigaGrid extends React.Component<GigaProps & ClassAttributes<GigaGrid>, GigaState> {

    private store: ReduceStore<GigaState, GigaAction>;
    private dispatcher: Dispatcher<GigaAction>;
    
    // This is very bad.  Good thing we have started the process to rewrite this
    private lastYScrollAmount = 0;

    static defaultProps: GigaProps = {
        initialSubtotalBys: [],
        initialSortBys: [],
        initialFilterBys: [],
        data: [],
        columnDefs: [],
        rowHeight: '25px',
        collapseHeight: false,
        additionalUserButtons: []
    };

    private static createStore(props: GigaProps, dispatcher: Dispatcher<GigaAction>): ReduceStore<GigaState, GigaAction> {
        if (props.useServerStore) {
            return new ServerStore(dispatcher, props);
        } else {
            return new GigaStore(dispatcher, props);
        }
    }

    constructor(props: GigaProps) {
        super(props);
        this.dispatcher = new Dispatcher<GigaAction>();
        this.store = GigaGrid.createStore(props, this.dispatcher);
        this.state = this.store.getState();
        // do not call setState again, this is the only place! otherwise you are violating the principles of Flux
        // not that would be wrong but it would break the 1 way data flow and make keeping track of mutation difficult
        this.store.addListener(() => {
            this.setState(this.store.getState());
        });
    }

    submitColumnConfigChange(action: GigaAction) {
        this.dispatcher.dispatch(action);
    }

    render() {

        let columns: Column[][];
        const state = this.store.getState();
        columns = [state.columns];

        const bodyStyle: any = {};

        /**
         * As noted in the collapseHeight property of the GigaProps interface, if collapseHeight is true, the table will
         * collapse to the height of the table itself it is smaller than the container
         */
        let { bodyHeight } = this.props;
        if (this.props.collapseHeight) {
            bodyStyle.maxHeight = bodyHeight;
        } else {
            bodyStyle.height = bodyHeight;
        }
      
        /**
         * We need to figure out what columns go in which sub table depending on how many static left headers there are
         */
        const allCols = columns[columns.length - 1];
        let leftCols, rightCols;
        // Static headers experience a latency issue in internet explorer.  Let's not enable it for now
        if (isNaN(this.props.staticLeftHeaders)) {
            leftCols = [];
            rightCols = allCols;
        } else if (allCols.length > this.props.staticLeftHeaders) {
            let { staticLeftHeaders } = this.props;
            leftCols = allCols.slice(0, staticLeftHeaders);
            rightCols = allCols.slice(staticLeftHeaders, allCols.length - staticLeftHeaders + 1);
        } else {
            throw 'Please declare a staticLeftHeaders prop which is less than the number of columns in the table.';
        }
        let placeholderHeights = this.calculatePlaceholderHeight();

        let rows = state.rasterizedRows.slice(state.displayStart, state.displayEnd + 1);

        return (
            <div className={`giga-grid giga-grid-${this.state.gridID}`}>
                {this.renderSettingsPopover()}
                <div className="giga-grid-header-container">
                    <TableHeader dispatcher={this.dispatcher}
                                 columns={columns}
                                 tableHeaderClass={this.props.tableHeaderClass}
                                 staticLeftHeaders={this.props.staticLeftHeaders}
                                 gridProps={this.props}/>
                </div>
                <div ref={c=>state.viewport=c}
                     className="giga-grid-body-viewport"
                     style={bodyStyle}>
                    {
                        leftCols.length === 0 ? null :
                            <div
                                className="frozen"
                                ref={(c) => state.leftBody = c}
                                style={{ height: bodyHeight }}>
                                <FrozenTableBody
                                    dispatcher={this.dispatcher}
                                    rows={rows}
                                    columns={leftCols}
                                    rowHeight={this.props.rowHeight}
                                    gridProps={this.props}
                                />
                            </div>
                    }
                    <div
                        ref={(c) => state.rightBody = c}
                        className="scrollable"
                        style={{ height: bodyHeight }}>
                        <ScrollableTableBody
                            dispatcher={this.dispatcher}
                            rows={rows}
                            columns={rightCols}
                            rowHeight={this.props.rowHeight}
                            gridProps={this.props}
                        />
                    </div>
                    <div style={{ height: `${placeholderHeights.lowerPlaceholderHeight}px` }} />
                </div>
            </div>
        );
    }

    componentWillReceiveProps(nextProps: GigaProps) {
        const payload: InitializeAction = {
            type: GigaActionType.INITIALIZE,
            props: nextProps
        };
        this.dispatcher.dispatch(payload);
        this.expandTable();
    }
    
    /**
     * on component update, we use jquery to align table headers
     * this is the "give up" solution, implemented in 0.1.7
     */
    componentDidUpdate(prevProps, prevState) {
        if (this.state.rasterizedRows.length !== prevState.rasterizedRows.length ||
            this.state.displayStart !== prevState.displayStart ||
            this.state.filterBys !== prevState.filterBys ||
            this.state.sortBys !== prevState.sortBys ||
            this.state.subtotalBys !== prevState.subtotalBys)
            this.synchTableHeaderWidthToFirstRow();
        
        const node: Element = ReactDOM.findDOMNode<Element>(this);
        const dataContainer = $(node).parent().find('.giga-grid-right-data-container');
        const scrollTopAmount: number = dataContainer.scrollTop();
        console.log(scrollTopAmount);
        $(node).parent().find('.giga-grid-left-headers-container').scrollTop(this.lastYScrollAmount);
        $(node).parent().parent().find('.giga-grid-right-data-container').scrollTop(this.lastYScrollAmount);
    }

    private calculatePlaceholderHeight() {
        let { rowHeight } = this.props;
        let { displayStart, displayEnd, rasterizedRows } = this.state;
        let rowHeightInt: number = parseInt(rowHeight);
        return {
            upperPlaceholderHeight: Math.max(displayStart * rowHeightInt, 0),
            lowerPlaceholderHeight: Math.max((rasterizedRows.length - displayEnd) * rowHeightInt, 0)
        };
    }

    /**
     * I don't love this, but it's only related to scrolling and has nothing to do with state/rendering of the component
     * so rather than making a re-render happen with a state change, we do this.  This is to fix this problem:
     * http://stackoverflow.com/questions/26326958/stopping-mousewheel-event-from-happening-twice-in-osx
     */
    private shouldScroll = true;

    // We need to define the exact function to use to bind event listeners to so we can remove them properly on unmount
    private handleVerticalScroll = (e: Event) => {
        e.preventDefault();
        const node: Element = ReactDOM.findDOMNode<Element>(this);
        const dataContainer = $(node).parent().find('.giga-grid-right-data-container');

        const scrollLeftAmount: number = dataContainer.scrollLeft();
        const scrollTopAmount: number = dataContainer.scrollTop();
        this.lastYScrollAmount = scrollTopAmount;
        $(node).parent().find('.giga-grid-left-headers-container').scrollTop(scrollTopAmount);
        $(node).parent().parent().find('.right-scrolling-headers').scrollTop(scrollTopAmount);
        $(node).parent().parent().find('.right-scrolling-headers').scrollLeft(scrollLeftAmount);
        this.dispatchDisplayBoundChange();
        return false;
    }

    /**
     * A wheely important function.  You can't scroll normally in the left-headers area, but a user would expect the
     * table to scroll if he or she uses the mousewheel.  So we have to listen for this event.
     */
    private handleWheelScroll = (e: any) => {
        e.preventDefault();
        e.stopPropagation();
        let { viewport } = this.state;
        this.shouldScroll = false;
        // This covers all browsers, see https://www.sitepoint.com/html5-javascript-mouse-wheel/
        const amountToScroll: number = -Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))) * 53;
        const node: Element = ReactDOM.findDOMNode<Element>(this);
        const dataContainer = $(node).parent().find('.giga-grid-right-data-container');
        const scrollTopAmount: number = dataContainer.scrollTop();
        this.lastYScrollAmount = scrollTopAmount + amountToScroll;
        $(node).parent().find('.giga-grid-left-headers-container').scrollTop(scrollTopAmount + amountToScroll);
        $(node).parent().parent().find('.giga-grid-right-data-container').scrollTop(scrollTopAmount + amountToScroll);
        this.dispatchDisplayBoundChange();
        return false;
    }

    private dispatchDisplayBoundChange() {
        let { rowHeight, bodyHeight } = this.props;
        const action: ChangeRowDisplayBoundsAction = {
            type: GigaActionType.CHANGE_ROW_DISPLAY_BOUNDS,
            rowHeight: rowHeight,
            bodyHeight: bodyHeight
        };
        this.dispatcher.dispatch(action);
    }

    componentDidMount() {
        /*
         * subscribe to listeners
         */
        if (typeof window !== "undefined") {
            window.addEventListener('resize', this.synchTableHeaderWidthToFirstRow.bind(this));
            this.enableScrollHandlers();
        }

    private handleWindowResize = () => {
        /**
         *  we will almost certainly operate in an environment where we do not know the component's width until after the component has mounted,
         *  so here we dispatch an event to resize the grid as appropriate
         */
        setTimeout(() => {
            let { dispatcher } = this;
            let node = ReactDOM.findDOMNode(this);
            dispatcher.dispatch({
                type: GigaActionType.VIEWPORT_RESIZE,
                newGridWidth: `${node.clientWidth}px`
            } as GridResizeAction);
        });
    }

    componentWillUnmount() {
        /*
         * unsubscribe to listeners
         */
        if (typeof window !== "undefined") {
            window.removeEventListener('resize', this.synchTableHeaderWidthToFirstRow);
            this.disableScrollHandlers();
        }
    }

    private encapsulatedScrollHandler = (e) => this.scrollHandler(e);
    private encapsulatedWheelScrollHandler = (e) => this.wheelScrollHandler(e);
    
    // Bind scroll listener to move headers when data container is scrolled
    private enableScrollHandlers(){
        const node: Element = ReactDOM.findDOMNode<Element>(this);
        const leftPanel: Element = $(node).find('.giga-grid-left-headers-container').get(0);
        const rightPanel: Element = $(node).find('.giga-grid-right-data-container').get(0);
        rightPanel && rightPanel.addEventListener('scroll', this.encapsulatedScrollHandler);
        rightPanel && rightPanel.addEventListener('mousewheel', this.encapsulatedWheelScrollHandler);
        rightPanel && rightPanel.addEventListener('MozMousePixelScroll', this.encapsulatedWheelScrollHandler);
        leftPanel && leftPanel.addEventListener('mousewheel', this.encapsulatedWheelScrollHandler);
        leftPanel && leftPanel.addEventListener('MozMousePixelScroll', this.encapsulatedWheelScrollHandler);
    }

    // Unbind the scroll listeners
    private disableScrollHandlers(){
        const node: Element = ReactDOM.findDOMNode<Element>(this);
        $(node).find('.giga-grid-right-data-container').unbind('scroll', this.scrollHandler);
        const leftPanel: Element = $(node).find('.giga-grid-left-headers-container').get(0);
        const rightPanel: Element = $(node).find('.giga-grid-right-data-container').get(0);
        rightPanel && rightPanel.removeEventListener('scroll', this.encapsulatedScrollHandler);
        rightPanel && rightPanel.removeEventListener('mousewheel', this.encapsulatedWheelScrollHandler);
        rightPanel && rightPanel.removeEventListener('MozMousePixelScroll', this.encapsulatedWheelScrollHandler);
        leftPanel && leftPanel.removeEventListener('mousewheel', this.encapsulatedWheelScrollHandler);
        leftPanel && leftPanel.removeEventListener('MozMousePixelScroll', this.encapsulatedWheelScrollHandler);
    }

    private dispatchDisplayBoundChange() {
        const state = this.store.getState();
        const $viewport = $(state.viewport);
        const $canvas = $(state.canvas);
        const action: ChangeRowDisplayBoundsAction = {
            type: GigaActionType.CHANGE_ROW_DISPLAY_BOUNDS,
            canvas: $canvas,
            viewport: $viewport,
            rowHeight: this.props.rowHeight,
            bodyHeight: this.props.bodyHeight
        };
        this.dispatcher.dispatch(action);
    }

    private expandTable() {
        if (this.props.expandTable) {
            this.dispatcher.dispatch({
                type: GigaActionType.EXPAND_ALL
            });
        }
    }

}

export function getHorizontalScrollbarThickness() {
    const el: any = document.createElement('div');
    el.style.visibility = 'hidden';
    el.style.overflow = 'scroll';
    document.body.appendChild(el);
    const h = el.offsetHeight - el.clientHeight;
    document.body.removeChild(el);
    return h;
}
